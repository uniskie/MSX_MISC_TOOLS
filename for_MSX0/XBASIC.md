# MSX2,MSX MSXべーしっ君

## 目次

- [概要](#%E6%A6%82%E8%A6%81)
- [べーしっ君の使用法](#%E3%81%B9%E3%83%BC%E3%81%97%E3%81%A3%E5%90%9B%E3%81%AE%E4%BD%BF%E7%94%A8%E6%B3%95)
- [リファレンス](#%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9)
- [MSX-BASICとの相違点](#MSX-BASIC%E3%81%A8%E3%81%AE%E7%9B%B8%E9%81%95%E7%82%B9)
- [べーしっ君で追加された命令](#%E3%81%B9%E3%83%BC%E3%81%97%E3%81%A3%E5%90%9B%E3%81%A7%E8%BF%BD%E5%8A%A0%E3%81%95%E3%82%8C%E3%81%9F%E5%91%BD%E4%BB%A4)
- [プログラミング上の注意点](#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E4%B8%8A%E3%81%AE%E6%B3%A8%E6%84%8F%E7%82%B9)
- [Appendix](#Appendix)

# 概要

　MSXベーしっ君は、メモリ上の BASICプログラムをその場で機械語プログラムに変換し、高速で実行する実数型のコンパイラです。入出力命令などの一部のものを除き、普通の MSX-BASICで書かれたプログラムをほとんど変更することなくコンパイルすることができます。使用法も非常に簡単で、従来のコンパイラのような、ソース作成、コンパイル、実行、といったステップをまったく意識させず、単に全体を素晴らしく速く実行させるコマンドがインタープリタ上に加わったというふうに捉えることができます。実数型の BASICコンパイラとしては、 15～20倍という実行速度は非常に優れており、 リアルタイムのゲーム、厖大な計算を必要とする C.G.デモプログラムなど多くの用途を考えることができます。

　特徴としては、
- 実数、文字変数をサポートしている。
- 割り込みをサポートしている。
- 配列の次元はメモリサイズによってのみ制限される。
- MSX-BASICと基本的に文法が同じで、かつ共存するので、 MSXBASICでデバッグして、ベーしっ君で実行させることが、非常に簡単にできる。
- プログラムの一部だけをコンパイルして実行させることができる。これによってベーしっ君がサポートしていないステートメントはMSXBASICで実行させて、高速化が必要な部分はベーしっ君で実行させるといったことが、プログラムの中で自由に切り換えられる。またこの時、 MSX-BASICとベーしっ君の間で変数の共有ができる。

　制限としては、
- 実数の精度が低い(有効数字約4.5桁)。
- 文字変数の使用効率が悪い。
- ファイル入出力関係のコマンド、ステートメントがサポートされていない。
- コンパイルしたオブジェクトの SAVE、LOADができない。
- MSX-BASICと少し文法の違うステートメントが存在する。
以上の理由により、既存の BASICプログラムすべてがコンパイルして実行できる訳ではありませんので御注意ください。お使いになる時はこのマニュアルの本文中の説明をよく読んでください。

# べーしっ君の使用法

　MSXベーしっ君のカートリ ッジ をスロットに差込み、 システムを起動します。このとき、通常の MSX-BASICが起動したときと同じ状態になりますが、実際には、 CALLRUNおよび CALLTURBO ON/OFFという 3つのコマンドが実行可能となっています。 MSX-00Sが起動している場合はまず BASICのモードに移行すれば同様の状態となります。
　BASICが起動したら、まず Sample1のプログラムをキーボードから入力してください。
そして

Sample1

```
10 SCREEN 8
20 FOR I=1 TO 5
30  CIRCLE(128, 105),1*20,255
40 NEXT I
50 IF INKEY$="" THEN 50
```

```CALL RUN⏎```

とすると、プログラムはす ぐにコ ンパイルされ、実行されます。このときコ ンパイ ルできない命令や、ェラーがあればコンパイル中、または実行中にエラーメ ッセー ジを出して停止します。コ ンパイルできない命令を含むプログラムは、実行できる部分だけを、

CALL TURBO ONとCALLTURBO OFF

の中に納めるように書き換え、全体を普通の RUNで実行します。

たとえば次のようなプログラムでは BLOADがコンパイルできないので、TURBOの外側に書いておきます。

Sample2

```
10 SCREEN 8
20 BLOAD"PICTURE",S
30 CALL TURBO ON
40 LINE(0,0)-(255,211),0,BF
50 CALL TURBO OFF
60 END
```

　このプログラムを RUNすると 30行と 50行の間だけがコンパイルされ、そのほかはまったく普通の BASICと同様に実行されます。一つのプログラムの中には TURBOON /OFFの組はいくつでてきてもかまいませんが、必ず一組づつ閉じていなければエラーとなります。また TURBO ON/OFFが使われているプログラムは、 CALLRUNで実行することはできませんが、そのかわり RUN“ ファイル名''でも実行することが可能となります。また CALLTURBO ON /OFFはダイレクトモードでは実行できません。

　CALL TURBO ON, CALL TURBO OFF共にマルチステートメント中には置けません。必ず独立した 1行の中におさめてください。
　普通の BASICの部分と、 TURBOで囲まれた部分では、変数や配列は別々に定義されます。従って、その内外では同じ変数名でも違った値を持つことになります。また一旦 TURBOOFFでひとつのブロックが終わると、その中で使われていた変数や配列はすべて無効となります。ただし整数型の変数と配列に限って、ブロックの内外で共通のものとして宣言することができます。このときは CALLTURBO ONの後に必要な変数、配列名をかっこでくくって並べます。

```
CALL TURBO ON (A, B%, C(), DE%())
```

　これで、 TURBOON以前に使われていた、 A,B%, (いずれも整数型の変数)および、 C(),DE%(), (いずれも整数型の配列)は共通の値を持ちます。

　CALL RUNまたは CALLTURBO ONで実行される部分では、実数型の変数は普通の BASICとは少し違っています。まず型は、!マークで表す単精度一種類だけで、倍精度はありません。更にこの単精度の変数も精度は約4.5桁で、範囲は正負の 2.939E-39～1.701E+38までです。
　また、 10000以上の浮動小数は「 E形式」で表示されます。実数型の関数、演算はすべてこの型に準じているので、普通の BASICとは若干違った計算結果となります。また、配列はプログラムの一番始めの実行可能な文として (CALLTURBO ONのときはその直後)宣言してください。宣言していない配列は扱うことができません。配列は何次元でもメモリの許す限り使えます。

　無限ループを作る (10 GOTO 10のような)と、[CTRL]+[STOP]によってもプログラムの実行を止めることができなくなります。必要な場合はキー入力待ちをする部分を作るなどして、止められるようにしておいてください。

# リファレンス

コンパイルできない命令、関数は以下の通りです。

## MSX-BASIC

```
AUTO, BASE, BLOAD, BSA VE, CALL, CDBL
CINT, CLEAR, CLOAD, CLOAD?, CLOSE
CONT, CSAVE, CSNG, DEFFN, DELETE
DRAW, EOF, ERASE, ERL, ERR, ERROR
FRE, GET, INPUT#, KEY LIST
LINEINPUT #, LIST, LLIST, LOAD
LPRINT USING, MAXFILES, MERGE
MOTOR, NEW, ON ERR(!)R GOTO, OPEN
PLAY, PRINT#, PRINT# USING
PRINT USING, PUT KANJI, RENUM
RESUME, SA VE, SPC, TAB, TRON, TROFF
WIDTH
```

## MSX-DISK-BASIC

```
CVD, CVI, CVS, DSKF, FIELD, FILES
FPOS, KILL, LFILES, LOC, LOF, LSET
MKD$, MKI$, MKS$, NAME, RSET
```

## 論理演算子

```
EQV, IMP
```

# MSX-BASICとの相違点

　つぎの命令、関数では使用範囲が限られます。

|       |   |
|-------|---|
|CIRCLE |開始、終了の角度および比率は指定できません。
|COPY   |グラフィック画面上の COPY文以外は使えません。
|DEFDBL |DEFSNGと同じです。 A!とA#は同じ変数を参照します。
|DIM    |すべての実行文に先立って宣言し、添字は整数の定数で指定します。実行文というのは、コンパイル時にオブジェクトを生成するようなステートメントのことです。<br>つまり DIMのまえに置けるのは DEFINT,DEFSNG, DEFDBL, DATA, DIM, コメントだけです。
|INPUT  |一度に代入できる変数は一つだけです。
|KEY    |ON KEY GOSUB, KEY (N) ONなど以外では使えません。
|LOCATE |X, Y座標は必ずセットで指定し、カーソルスイッチは指定できません。
|NEXT   |NEXTの後の変数名は省略できません。
|ON     |ON STOP GOSUBは使えません。<br> （ON ERROR GOTO も使えないと思います）
|PRINT  |カンマの働きが違います。 MSX-BASICではカンマは有効数字の最大桁数に相当するスペースを出力しますが、ベーしっ君ではタブコードを出力するだけです。また、数値出力の画面上のラップは行われません。
|PUT    |PUT SPRITE以外は使えません。
|RUN    |変数の初期化は行われません。
|SCREEN |スクリーンモード、スプライトサイズ以外は指定できません。
|SET    |SET PAGE以外は使えません。
|STOP   |ENDと同じです。
|USR    |引数として使える値は、整数に限ります。
|VARPTR |ファイル番号を引数として指定することはできません。

これ以外の命令、関数は普通の BASICとまったく同様に扱うことができます。


# べーしっ君で追加された命令

　すでに説明した通り、ベーしっ君には CALLRUNとCALLTURBO ON/OFFという拡張命令がありますが、この項では、それ以外の拡張命令について説明します。
　ベーしっ君では、コメントを特殊なキャラクタで始めることにより、命令を拡張しています。
(コメントは「REM」でも「＇」でも構いません。「#」の後にくるキャラクタは大文字でも小文字でも構いません。)

## #I

　INLINEの略で、プログラム中に機械語プログラムを記述します。

### 機能

　数字を書くとその値(バイト)がメモリに置かれます。変数名(整数型の単純変数に限る)を書くとその変数のアドレス(ワード)がメモリに置かれます。“@"が頭に付いた10進数を書くとその数で示される行番号に対応するオブジェクトのアドレス(ワード)がメモリに置かれます。
この行番号は RENUM命令でも、リナンバーされないので注意してください。

### 例

　ベーしっ君では、 “OPEN","PRINT#"が使えないのでそれを補うためのグラフィック画面に文字を出力するサブルーチンです。 20行のPRESET文で出力位置を決め、 25～35行の FOR～NEXTループでC%に文字のキャラクタコードを代入しています。そして30行で、機械語サブルーチンを呼び出しています。 100～160行までが機械語サブルーチンですが、その中から更に170行の BASICのサブルーチンを呼ぶ形式になっているので、御自分のプログラムに組み忍む際には170行を忘れないようにしてください。この例の場合には、 130行中の “@170"がそうです。機能の項で説明した通り、この “@170''は RENUM命令でもリナンバーされないので注意してください。

Sample3 グラフィック画面用文字出カルーチン

```
10 SCREEN 5:X%=0:Y%=0
20 PRESET(0,0)
25 FOR C%=0 TO 255
30  GOSUB 100
35 NEXT C%
40 IF INKEY$="" THEN 40
50 END
100 '#I &H2A,C%,&H29,&H29,&H29,&H11,&HBF,&H1B,&H19
110 '#I &H06,&H08,&H3A,&HB7,&HFC,&H32,X%,&H3A,&HB9,&HFC,&H32,Y%
120 '#I &H7E,&H23,&HC5,&H06,&H08
130 '#I &H17,&HF5,&HC5,&HE5,&HDC,●170,&HE1,&HC1,&H3A,X%,&H3C,&H32,X%,&HF1
140 '#I &H10,&HED,&H3A,X%,&HD6,&H08,1H32,X%,&H3A,Y%,&H3C,&H32,Y%,&HC1,&H10,&HD6
150 '#I &H3A,X%,&HC6,&H08,&H32,&HB7,&HFC,&H3A,Y%,&H38,2,&HD6,&H08
160 '#I &H32,&HB9,&HFC,&HC9
170 PSET(X%,Y%):RETURN
```

### 注意点

1. X%, Y%は別の変数名にもできますが、整数型でなければいけません。
2. このサブルーチンでは、 X座標は 0～255までです。
3. 画面には ORで出力しています。
4. “月火水木金"などのグラフィックキャラクタは MSX-BASICと違い、直接10進数のコードを代入して呼び出せます。

　この機械語サブルーチンの内部構造をもっとくわしく知りたいという方のために、このマニュアルの巻末にソースリストを載せてありますので参考にしてください。

## #C

　CLIPの略で、Y座標のクリッピングの ON/OFFを行うコードを生成します。

### 機能

「#C+」でクリッピングを ONにし (MSX-BASICと同じ)、「#C-」でクリッピングを OFFにします。ベーしっ君起動時には ONが設定されています。

### 例

Sample4

```
10 SCREEN 8
20 '#C-
30 LINE(0,0)-(255,255)
40 IF INKEY$="" THEN 40
50 '#C+
60 LINE(0,0)-(255,255)
70 IF INKEY$="" THEN 70
```

### 注意点

1. ベーしっ君では、 9918互換モード (SCREEN0～3)や、 PAINT,CIRCLE命令の実行には、MSX-BASICのルーチンをコールしているため、これらのときにはこの指定は意味を持ちません。

## #N

NEXTの略で、NEXTステートメントのコンパイル時にオーバーフローをチェックするコードを生成するかどうかを決めます。

### 機能

「#N+」とすると、それ以降の NEXTのコンパイルにおいてオーバーフローをチェックし、そうならループから脱出するようなオブジェクトを生成します。「#N-」とすると、オーバーフローをチェックしないオブジェクトを生成します。ベーしっ君起動時には「#N+」が設定されています。

### 例

Sample5

```
10 FOR I%=0 TO &H7FFF
20 NEXT I%
```

　このプログラムを MSX-BASICで実行させると、ループの終了直前にエラーが起きます。これは、&H7FFFに 1を足した結果、値が整数の範囲を越えたことによって起こります。一方ベーしっ君で実行させると、無限ループにおちいります。&H7FFFより大きい整数はベーしっ君では存在しないからです。そのような状態を回避したい時にこの命令を用いてください。

### 注意点

1. 「#N+」とすると、オブジェクトサイズ、実行時間共に増加します。
2. この命令を使ったプログラムは MSX-BA$ICでは、正しく動かなくなります。

# プログラミング上の注意点

　ベーしっ君は MSX-BASICと互換性があるように設計されていますが、コンパイラという性格上どうしても避けられない相違点や、あるいはベーしっ君の都合上の相違点があります。コンパイルしたがエラーが起こる。コンパイルはされたがうまく動かないなどの事が起こったら、以下に示す点をチェックしてください。

- あらかじめ定義された整数型の変数、配列に限ってプログラム中のBASICの部分と CALLTURBO ON/OFFで囲まれた部分に共通の値を持たせることができるというのは使用法の項で説明しましたが、もし定義していない変数や配列を渡そうとすると “Illegal function call"のエラーが起こります。このエラーが出たら、変数や配列の定義がきちんとされているかどうかを調べてください。
- パラメータや添字の範囲のチェックは行われません(ただし配列の次元はコンパイル時にチェックされます)。 MSX2特有のステートメントを MSXで実行させた場合の動作は保証されません。ベーしっ君は本体をコンパクトにするのと、動作の高速化のためにエラーチェックが簡略化されています。 MSX-BASICで正常に動作するのを確認してから、ベーしっ君で実行してください。
- FOR～NEXT ループは、プログラム中で正しく対応していなければいけません。
- MSX-BASIC では、要素数が10 までの配列は宣言しなくても使えますが、ベーしっ君では配列は必ず DIMを使って宣言しなければいけません。
- ベーしっ君での宣言 (DEFINT,DEFSNG, DEFDBL, コメント中の#N) は静的になされます(実行中に効果を発生するのではありません)。つまりプログラム中に現れる順番に依存します。例えば下のプログラムでは MSX-BASICとベーしっ君では実行結果が違います。

Sample6

```
10 GOSUB 50
20 A=100/3
30 PRINT A
40 END
50 DEFINT A
60 RETURN
```

- USR関数の実行時のメモリマップは MSX-BASICとベーしっ君で結果が違います。 MSX-BASICの時はページ 1 (4000H～7FFFH) にMSX-BASICが見えていますが、ベーしっ君の時はベーしっ君が見えています。
- USR関数に渡したり受け取ったりする値は、整数に限ります。
- 文字列および文字型の変数、配列、関数、演算は普通の BASIC同様使えますが、一つの変数(または配列の一要素)ごとに256バイトを使ってしまうので、メモリの配分に注意が必要です。
- 割り込みを使用するとオブジェクトサイズ、実行時間共に増加します。
- MSX-BASIC では、 10段の文字列のスタックを持っていて、これによって複雑な文字列演算を実行できますが、ベーしっ君では文字列のスタックが 1段(というより固定ワークエリアが一つ)しかありません。  
  よって、 MSX-BASICで実行できた文字列演算がコンパイルできないことが起こり得ます。

Sample7-a

```
10 B$="41"
20 A$=C$+CHR$(VAL("&H"+B$))
```

この例ではコンパイル時に “Stringformula too complex in 20" というエラーが発生します。文字列のスタックを使う命令は、文字列の連結と文字列の比較です。このエラーを避けるためには、文字列演算をできるだけ分割するようにしてください。例えば Sample7-aのプログラムは次のように変更すると、正常に実行できるようになります。

Sample7-b

```
10 B$="41"
20 C$=CHR$(VAL("&H"+B$))
30 A$=A$+C$
```

- ベーしっ君では割り算、べき乗以外の演算では、特別の場合を除き整数同士の演算結果は必ず整数に収まると仮定しています。例えばA%が200の時、 A%*A%は MSX-BASICでは浮動小数の40000になりますが、ベーしっ君ではー25536になります(オーバーフローを無視しているため)。これを MSX-BASICに合わせるようにすると、オブジェクトサイズ、実行速度共に極端に低下してしまいますので、どうか目をつぶってください。 1!*A%*A%とすると MSX-BASICと同一の結果となります。

  「特別の場合」とは、「式の最終的な値が浮動小数になるということをベーしっ君が前もって分かっている場合」です。例えば、浮動小数変数への代入とか浮動小数関数の引数の評価等です。ただしこれも完璧ではなくて、LOG(1+A%*A%)のような場合(優先順位が高い演算子が右にくる場合)は MSX-BASICと同じ結果が得られません。

## 速いオプジェクトを作るには

- 変数はできるだけ整数型にしてください。
- プログラム中の演算子には「/」や「 I¥」はなるべく使わないで、「¥」や「*」を使うようにしてください。
- 整数の割り算の時はなるべく、2のN乗倍の数で割るようにしてください。
- 整数の掛け算の時はなるべく、2のN乗倍の数か、3, 5, 6, 7, 9, 10, 20, 25, 40, 50, 80, 100, 200, 256, 257で掛けるようにしてください。このようにすると演算速度が飛躍的に向上します。
- 配列の添字はなるべく「上記の数ー 1」の形になるようにしてください。 255が一番効率が良くなります。また他次元配列では、この形の添字がなるべく左にくるように定義してください。

## メモリ制限について

　ベーしっ君は、ソーステキスト (BASICプログラム)とオブジェクトプログラムが同じ RAM上にあるので、メモリの制限がきびしくなります。大体の目安としては 32K,64Kシステムで lOKバイトぐらいのプログラムはコンパイルして、実行することができますが、次のような場合は更にきびしくなることは覚えておくと良いでしょう。
1. ディスクドライブなどによってメモリのフリーエリアの上限が限られている場合。
2. CLEAR, MAXFILES命令などで余分にメモリが使われている場合。
3. すでに非常に圧縮した BASICプログラムのテキストで、余分なスペースなどが殆ど入っていないプログラムの場合。
4. 割り込み命令を使った場合。
5. 多くの文字列変数や、大きな配列を使っている場合。

　1や2の場合はコンパイル時には CLEAR文でメモリの上限を最大(&HF380)に宣言し直すことで助けになりますが、実行後はディスクのアクセスができなくなる、機械語プログラムが使えなくなるなどの弊害もあるので注意が必要です。特に接続した時に&HFD9F番地の内容が&HC9になっていないようなディスクドライブなどがつながっている場合は、 CLEAR10, &HF380などを実行するといきなり暴走することがあります。これはタイマー割り込みで&HF380より下位の番地にあるプログラムが呼び出されているということで、このプログラムを壊してしまう前に、 POKE&HFD9F, &HC9を実行しておいたほうが良いでしょう。

　それ以外の場合で、 Outof memoryとなってしまった場合は、できるだけ整数型の変数を使う、同じような部分はサブルーチンにまとめる、余分なスペースはつめる、できる限りマルチステートメントを使って行数を減らすなどしてメモリを節約してください。

## 変数の内部形式について

　テキスト中の定数や、整数型の変数については普通の BASICと変わりません。実数型の変数は 1つにつき 3バイト、文字型の変数は 1つにつき 256バイトを使います。内部の形式は次のようになっていますので、機械語プログラムなどとインターフェースを取るときの参考にしてください。

### 実数型

　すべての実数は 1バイトの指数部と 2バイトの仮数で表現されています。仮数は0.5以上 1未満として計算し、これに 2のN乗をかけたものとしています。例えば 1という数値は、

　0.5X 2の1乗

　ですから、 80Hのゲタをはかせて指数部が 81Hとします。指数部がマイナスのときは 7FH(マイナス 1乗)、 7EH(マイナス 2乗)というふうになるわけです。これが VARPTR関数で示される番地に格納されています。

　次に仮数は16ビットで0.5～1未満ですから 8000Hが 0.5, FFFFHが 1未満の最大の仮数に対応します。このとき MSBは必ず立っていることになるので正負の符号として転用します。つまり 0.5なら 0000H、-0.5なら 8000Hとするのです。こうしてできた仮数が下位バイト、上位バイトの順に指数部に続いて格納されています。したがって 1という値は、81H, 00H, 00Hというふうに格納されています。別の例をあげておきます。

```
-0.75=-(0.5+0.25) * 2の0乗
     =80H,00H,C0H
  120=(0.5+0.25+0.125+0.0625)
             * 2の.7乗
     =87H,00H,70H
```

　ただし値が 0のときだけは例外で、指数部がゼロということで表現します。 このとき仮数部は不定で、意味を持ちません。

### 文字型

　処理速度を上げるため、一つの文字型の変数はその文字列の長さ (0～255)とその内容が続けて格納されています。 VARPTR関数で示される番地に長さが入っています。続く 255バイトはたとえ使用しなくても(文字列の長さが255未満でも)この変数用に予約されるため、他の目的に転用することができません。

# Appendix

## サンプルプログラム「天体」

　プログラムを実行させると数字の入力を促してきますので、 100～300の数字を入れてください。最大 9個の惑星が回転します。ぜひベーしっ君と普通の BASICの両方で実行してみてください。速度の違いを実感されることと思います。

```
100 'TENTAI
110 DEFINT A-Z:DEFSNG A,B,H,I,K,M,P
120 DIM C(14),X(300,10),Y(300,10)
130 COLOR 15,0,0:SCREEN 0
140 INPUT "NUMBER(100-300)";L
150 FOR J=20 TO L
160  IF L MOD J=0 THEN C(N)=J:N=N+1
170 NEXT J
180 PRINT N;"PLANETS"
190 C=N-1:H=90/N:N=0:D=L
200 '
210 P=ATN(1)*4
220 PRINT"WAIT"
230 FOR J=0 TO C
240  K=RND(1)*P/2:L=C(J)/2:M=H*(J+1)
250  FOR I=0 TO P*2 STEP P/L
260   A=COS(I+K):B=SIN(I)
270   X(N,J)=A*M*1.5+128:Y(N,J)=B*M+96:IF X(N,J)>255 OR X(N,J)<0 THEN X(N,J)=-1
280   N=N+1
290  NEXT I
300  N=0
310 NEXT J
320 SCREEN 2:FOR J=&H3800 TO &H380F:VPOKE J,0:NEXT J
330 VPOKE &H3800,128:CIRCLE(128,96),4:PAINT(128,96)
340 IF 1E-40 THEN 350 ELSE IF INKEY$=CHR$(13) THEN END
350 FOR J=0 TO C
360  PUT SPRITE J,(X(N MOD C(J),J),Y(N MOD C(J),J)),15-J,0
370 NEXT J
380 N=(N+1) MOD D
390 GOTO 340
```

## グラフィック画面用文字出カルーチンソースリスト

```
;
;** SAMPLE FOR #I (PRINT # SUBSTITUTE) **
;
ROMFNT	EQU	1BBFH
GRPACX	EQU	0FCB7H
GRPACY	EQU	0FCB9H
C%	EQU	0	;Use C% to pass CHR code
X%	EQU	0	;Used in 170
Y%	EQU	0	;Used in 170
●170	EQU	0	;PSET routine in BASIC
;
	LD	HL,(C%)		;L100
	ADD	HL,HL		;Get ROM font address
	ADD	HL,HL		;corresponding to CHR$(C%)
	ADD	HL,HL
	LD	DE,ROMFNT	;Better refer to 67H to get
	ADD	HL,DE		;this address
	LD	B,8		;L119
	LD	A,(GRPACX}	;Get graphic accumulators
	LD	(X%),A
	LD	A,(GRPACY)
	LD	(Y%),A
L120:
	LD	A,(HL)		;Get a font byte
	INC	HL		;8 times
	PUSH	BC
	LD	B,8
L130:
	RLA			;Rotate the font byte
	PUSH	AF		;8 times
	PUSH	BC
	PUSH	HL
	CALL	C,●170		;Call a PSET routine in BASIC
	POP	HL
	POP	BC
	LD	A,(X%)		;Adjust the coordinate X
	INC	A
	LD	(X%),A
	POP	AF
	DJNZ	L130		;L140
	LD	A,(X%)		;Adjust the coordinates X,Y
	SUB	8
	LD	(X%),A
	LD	A,(Y%)
	INC	A
	LD	(Y%),A
	POP	BC
	DJNZ	L120
	LD	A,(X%)		;L150
	ADD	A,8		;Create graphic accumulators
	LD	(GRPACX),A	;for the next action
	LD	A,(Y%)
	JR	C,L160
	SUB	8
L160:
	LD	(GRPACY),A
	RET
```
