# MSX0 関連: IOT I/O ACCESS

MSX0 Iot ROM ver 0.05.04 での実装に基づいた情報です。
独自調査なので一部間違いがある可能性があります。

---

## SAMPLE

![BIGAJUU.png](img/BIGAJUU.png)
[BIGAJUU/](BIJAJUU/)  
[BIGAJUU.DSK](BIGAJUU.DSK)  

###

### 実装

- ジャイロ・加速度センサーの利用
  - タッチまたはトリガで位置リセット
  - 位置リセット時、Y軸の範囲外の時はZ軸に切り替え（逆も同様）
- べーしっ君存在チェック  
  あれば利用する  
  ない場合でも動作
- MSX0 IOT、ジャイロ・加速度センサーの存在チェック  
  あれば利用する  
  ない場合でも動作
- タッチパネルや傾きで目が動く
- 時計機能

## _TURBO ON/OFF TIPS

### ```ON STOP GOSUB 行番号```:```STOP ON```の挙動

- コンパイルモードでなければ使用できる。  

  コンパイルモードでは実行できないが、  
  ```_TURBO ON```の前や```_TURBO OFF```の後では使用できる。

- 飛び先行番号が```_TURBO ON```の前か```_TURBO OFF```の後でないと、基本的にエラーになる。

- ```_TURBO ON```の前に```ON STOP GOSUB 行番号```:```STOP ON```をしていた場合、  
  ```_TURBO ON```から```STOP OFF```までの間は反応しないが、  
  ```_TURBO OFF```の後に実行される。

### ```ON ERROR GOTO 行番号```の挙動

- コンパイルモードでなければ使用できる。  

  コンパイルモードでは実行できないが、  
  ```_TURBO ON```の前や```_TURBO OFF```の後では使用できる。

- 飛び先行番号が```_TURBO ON```の前か```_TURBO OFF```の後でないと、基本的にエラーになる。

- ```_TURBO ON```の前に使用していた場合、  
  - ```_TURBO OFF```の後に反応する。
  - ```_TURBO ON```実行でコンパイルする際に発生するエラーにも反応する。

### CTRL+STOPの挙動

- ```_TURBO ON```から```_TURBO OFF```の間に```CTRL+STOP```を押していると、  
  ```_TURBO OFF```の**直後**に実行がブレイクされてしまう。

  そのため、```_TURBO OFF```の後に（コンパイル実行できない）処理を書いていた場合、
  それらの処理が実行できない。

  H.TIMIフックを戻す処理など、終了時に必ず実行したい処理がある場合は、  
  ```_TURBO OFF```の前に実行すると良い。

  ```_TURBO ON```の前に```ON STOP GOSUB 行番号```:```STOP ON```を実行しておいて、  
  ON STOP 呼び出し先で処理しても良い。

### 呼び出し・ジャンプ可能な行番号の範囲

- ```_TURBO ON```～```_TURBO OFF```の間でだけアクセスできる。
- ```_TURBO ON```～```_TURBO OFF```の外から外ならアクセスできる。  

  例)  
  ```_TURBO ON```より前の行番号から  
  ```_TURBO OFF```より後の行番号がアクセスできる

---

## I/Oポート
- PORT 8 : IOT操作（入出力）
- PORT 16: ターミナルコンソールへの出力（出力）

## 基本の流れ
1. コマンド出力
2. データ出力 or データ取得

## ノードアクセスの流れ
1. コマンド出力（ノード指定）
2. ノード名出力
3. 1byte I/O読み込み→bit7が1なら存在しない
4. コマンド出力 (put/get/find)
5. データ出力 or データ取得


## (1) コマンド
```
#e0, #01, コマンド+型ID
```
> #e0 ... コマンド指定  
> #01 ... コマンドデータサイズ

### #50: ノード指定コマンド
  ```
	#e0,#01,#53
  ```
  - 型指定は文字列(3)で固定なので3バイト目は#53固定
  - ノード指定後にポートを1回読み込み、Bit7が立っていればエラー

###  #40: iotputコマンド
  ```
	#e0,#01,#40 + 型ID
  ```
###  #00: iotgetコマンド
  ```
	#e0,#01#,#00 + 型ID
  ```
###  #10: iotfindコマンド
  ```
	#e0,#01,#10 + 型ID
  ```

###   型ID
- 1=2バイト整数型
- 2=単精度実数型
- 3=文字列
- 4=倍精度実数型

## (2-A) #C0: データ出力
```
	#c0, データ長n, データ*n個, #00
```
> **CAUTION**  
> ※ データ長が64を超える場合は分割が必要  
> ```
> OUT #C0 ;データ出力の開始
> WHILE (データ長 > 64) 
>     #7Fを出力  
>     データを64byte出力
>     データ長 -= 64
>     データの位置 += 64
> LOOP
> IF (データ長 > 0)
>     データ長を出力
>     データを全部出力
> ENDIF
> OUT #00 ;データ出力の終了
> ```

### 2バイト整数出力:
```
	#c0, #02, 数値下位1byte, 数値上位1byte, #00
```

### 文字列出力:
```
	#c0, [データ長, 文字列], #00
```

## (2-B)  #80: データ取得
```
	(out)#80, (in)データ長n, データ*n
```

### 数値取得
```
	(out) #80, (in)データ長, (in)Low 1byte, (in) High 1byte
```

※ 現在は2バイト整数しか返さない
※ そのため、データ長は2byte決め打ちで読み捨てでも良い

### 文字列取得
```
	(out) #80, (in)データ長, (in)文字列データ*データ長分繰り返し
```
